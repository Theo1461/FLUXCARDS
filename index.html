<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>FLUX CARD</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;600;800&family=JetBrains+Mono:wght@700&display=swap');

        :root {
            --card-width: min(20vw, 90px);
            --card-height: calc(var(--card-width) * 1.4);
            --bg-color: #020202;
            --accent-glow: rgba(168, 85, 247, 0.4);
        }
        gamecanvas {
            height: 100vh;
            width: 100vw
        }
        body {
            font-family: 'Plus Jakarta Sans', sans-serif;
            background-color: var(--bg-color);
            color: #ffffff;
            touch-action: manipulation;
            user-select: none;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
            transition: background 2s ease-in-out;
        }

        .bg-day { background: radial-gradient(circle at top, #1e293b, #020617); }
        .bg-night { background: radial-gradient(circle at bottom, #020617, #000000); }

        .hud-layer {
            padding: env(safe-area-inset-top, 40px) 24px 10px;
            flex-shrink: 0;
            z-index: 20;
        }

        .field-layer {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .card-pill {
            flex: 0 0 var(--card-width);
            height: var(--card-height);
            border-radius: 14px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            border: 2px solid rgba(255,255,255,0.05);
            cursor: pointer;
        }

        .card-pill.selected {
            transform: translateY(-28px);
            border: 3px solid #fff;
            box-shadow: 0 15px 45px rgba(255,255,255,0.4);
            z-index: 10;
        }

        .card-pill.merge-selected {
            transform: translateY(-15px);
            border: 3px solid #fff;
            box-shadow: 0 0 20px rgba(255,255,255,0.5);
        }

        @keyframes pulse-border {
            0%, 100% { box-shadow: 0 0 5px #a855f7; }
            50% { box-shadow: 0 0 20px #a855f7; }
        }

        .c-red { background: #ff3b30; color: rgb(255, 196, 196); }
        .c-blue { background: #007aff; color: rgb(175, 218, 255); }
        .c-green { background: #34c759; color: rgb(195, 255, 202); }
        .c-yellow { background: #ffcc00; color:rgb(255, 238, 204) }
        .c-purple { background: #af52de; color:rgb(240, 207, 255); }
        .c-zinc { background: #d1d1d1; color: rgb(39, 39, 48); }

        .scroll-hand {
            display: flex;
            gap: 12px;
            overflow-x: auto;
            padding: 30px 20px 70px 20px;
            scrollbar-width: none;
        }
        .scroll-hand::-webkit-scrollbar { display: none; }

        .volatility-track {
            height: 6px;
            background: rgba(255,255,255,0.05);
            border-radius: 3px;
            overflow: hidden;
        }

        #vol-fill {
            height: 100%;
            width: 0%;
            background: #34c759;
            transition: width 0.3s ease;
        }

        .burn-active {
            box-shadow: 0 0 20px #ff3b30;
            animation: flicker 0.2s infinite;
        }
        
        .barrier-active {
            box-shadow: 0 0 20px #007aff;
            border: 2px solid #007aff !important;
        }

        @keyframes flicker { 0%, 100% { opacity: 1; } 50% { opacity: 0.8; } }

        .meltdown { animation: pulse-red 0.5s infinite; }
        @keyframes pulse-red { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

        .dock-layer {
            background: rgba(10, 10, 10, 0.95);
            backdrop-filter: blur(25px);
            border-top: 1px solid rgba(255,255,255,0.08);
            padding-bottom: env(safe-area-inset-bottom, 20px);
            flex-shrink: 0;
            z-index: 20;
        }
        .custom-scrollbar::-webkit-scrollbar { width: 4px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 10px; }

        .help-card-row {
            display: flex;
            align-items: center;
            gap: 16px;
            background: rgba(255,255,255,0.03);
            padding: 12px;
            border-radius: 20px;
        }
        .help-icon {
            width: 40px;
            height: 54px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 900;
            flex-shrink: 0;
        }
        .next-preview {
            width: 44px;
            height: 60px;
            border-radius: 10px;
            border: 2px solid rgba(255,255,255,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 800;
        }

        .msg-toast {
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255,255,255,0.9);
            color: black;
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 800;
            text-transform: uppercase;
            z-index: 100;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
        }

        .merge-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            z-index: 40;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .merge-overlay.active { opacity: 1; }
    </style>
</head>
<div id="gamecanvas">
<body id="game-body" class="bg-night">

    <div id="toast" class="msg-toast">LOADING</div>
    
    <div id="merge-ui" class="merge-overlay">
        <p class="text-white font-black tracking-widest uppercase text-sm mb-2">MERGE</p>
        <p class="text-white/60 text-[10px] uppercase font-bold" id="merge-instructions">Select two cards of the same color</p>
        <button onclick="cancelSpecialModes()" class="mt-6 text-[9px] font-black uppercase text-white/40 pointer-events-auto">Cancel Merge</button>
    </div>

    <div class="hud-layer">
        <div class="flex justify-between items-start mb-4">
            <div>
                <p class="text-[9px] font-blue text-zinc-500 uppercase">BEST: <span id="best-hud">0</span></p>
                <p class="text-[10px] font-black tracking-widest text-zinc-600 uppercase">SCORE</p>
                <h1 class="text-4xl font-extrabold tracking-tighter" id="score">0</h1>
            </div>
            <div class="flex flex-col items-end">
                <p class="text-[10px] font-black tracking-widest text-purple-500 uppercase">NEXT UP</p>
                <div id="next-card" class="next-preview mt-1">?</div>
            </div>
            <button onclick="toggleHelp(true)" class="fixed top-4 right-20 z-30 bg-white/10 border border-white/20 p-2 rounded-full hover:bg-white/20 transition-all">
    <span class="text-xs font-black px-2">?</span>
</button>

<div id="help-modal" class="hidden fixed inset-0 z-[100] bg-black/95 backdrop-blur-2xl flex items-center justify-center p-4">
    <div class="bg-zinc-900 border border-white/10 w-full max-w-lg max-h-[90vh] rounded-[40px] flex flex-col shadow-2xl overflow-hidden">
        
        <div class="p-6 border-b border-white/5 flex justify-between items-center bg-white/[0.02]">
            <div>
                <h2 class="text-2xl font-black italic tracking-tighter text-white">FLUX CARDS</h2>
                <p class="text-[10px] font-bold text-purple-500 uppercase tracking-widest">Guide</p>
            </div>
            <button onclick="toggleHelp(false)" class="bg-white/10 hover:bg-red-500/20 hover:text-red-500 w-10 h-10 rounded-full flex items-center justify-center transition-all font-bold">✕</button>
        </div>
        
        <div class="overflow-y-auto p-6 space-y-8 custom-scrollbar">
            <section>
                <h3 class="text-white font-black text-xs uppercase tracking-widest mb-2 border-l-2 border-purple-500 pl-2">The Goal</h3>
                <p class="text-zinc-400 text-sm leading-relaxed">
                    Score maximum points by playing <span class="text-white font-bold">Chains</span>. Match the center card's <span class="text-white font-bold">Color</span> or <span class="text-white font-bold">Number</span>. If it's <span class="text-zinc-300 font-bold">Zinc (Gray)</span>, any card works. If Entropy goes under 100%, you lose.
                </p>
            </section>

            <section>
                <h3 class="text-white font-black text-xs uppercase tracking-widest mb-4 border-l-2 border-purple-500 pl-2">Card Dictionary</h3>
                <div id="help-list" class="grid grid-cols-3 gap-3">
                    </div>
            </section>
        </div>


    </div>
</div>
        </div>
<div class="flex items-center gap-2">
    <span id="ai-status" class="text-[9px] font-black uppercase tracking-widest px-2 py-0.5 rounded bg-zinc-800 text-zinc-400">AI: STABLE</span>
</div>
        <div class="space-y-2">
            <div class="flex justify-between items-center">
                <div class="flex items-center gap-2">
                    <span id="status-label" class="text-[9px] font-black uppercase tracking-widest text-zinc-400">Entropy</span>
                    <span id="burn-indicator" class="hidden text-[9px] font-black uppercase tracking-widest text-red-500 bg-red-500/10 px-2 py-0.5 rounded">TRIPLE RED BONUS: <span id="burn-count">3</span></span>
                    <span id="barrier-indicator" class="hidden text-[9px] font-black uppercase tracking-widest text-blue-400 bg-blue-500/10 px-2 py-0.5 rounded">% BLOCKED: <span id="barrier-count">2</span></span>
                </div>
                <span id="vol-pct" class="text-[9px] font-black text-zinc-400">0%</span>
            </div>
            <div class="volatility-track">
                <div id="vol-fill"></div>
            </div>
            <div id="meltdown-timer" class="text-[10px] font-black text-red-500 uppercase text-center hidden pt-1">
                GAME OVER in <span id="timer-val">5.0</span>s
            </div>
        </div>
    </div>

    <div class="field-layer" id="main-field">
        <div id="target-card" class="w-32 h-44 sm:w-36 sm:h-52 rounded-[28px] flex items-center justify-center shadow-2xl border border-white/10 transition-all"></div>
        <div class="mt-8 h-12 flex flex-col items-center justify-center gap-4">
            <button id="action-btn" onclick="executeAction()" class="hidden bg-white text-black px-12 py-3 rounded-full font-black uppercase text-xs tracking-widest shadow-2xl active:scale-95 transition-all">
                Play Card
            </button>
        </div>
    </div>

    <div class="dock-layer">
        <div class="flex justify-between items-center px-6 pt-5">
            <div class="flex gap-2">
                <button onclick="drawCard()" class="bg-zinc-800 border border-white/5 px-3 py-2 rounded-xl text-[9px] font-black uppercase">Draw (+7%)</button>
            </div>
            <div id="hand-cap" class="text-[10px] font-black text-zinc-500 uppercase">0/15 Units</div>
        </div>
        <div id="hand" class="scroll-hand"></div>
    </div>

    <div id="game-over" class="fixed inset-0 z-50 bg-black/98 flex flex-col items-center justify-center opacity-0 pointer-events-none transition-opacity px-10 text-center">
        <h2 class="text-6xl font-black italic tracking-tighter text-red-600 leading-none mb-4">GAME OVER</h2>
        <div class="bg-zinc-900 p-8 rounded-3xl w-full max-w-xs mb-8 border border-white/5">
            <p class="text-[10px] uppercase font-bold text-zinc-600 mb-1">Score</p>
            <p class="text-4xl font-black" id="final-score">0</p>
        </div>
        <button onclick="resetGame()" class="bg-white text-black w-full max-w-xs py-5 rounded-full font-black uppercase tracking-widest text-sm">Restart</button>
    </div>
</div>
    <script>
        
        function toggleHelp(show) {
            const modal = document.getElementById('help-modal');
            if (modal) modal.classList.toggle('hidden', !show);
            if (show) renderHelp();
        }

        function renderHelp() {
            const list = document.getElementById('help-list');
            if (!list) return;

            const allCards = [
            { icon: '1-9', col: 'zinc', name: 'Standard', desc: 'Classic Color/Number Cards.' },
            { icon: '⚁', col: 'zinc', name: 'Dice', desc: 'Draw Random Cards/Entropy.' },
            { icon: '⎎', col: 'zinc', name: 'Shift', desc: 'Random Targets Cards.' },
            { icon: '⧈', col: 'zinc', name: 'Merge', desc: 'Combine 2 Cards.' },
            { icon: '+2', col: 'zinc', name: 'Boost', desc: 'Given 2 Cards/No Entropy.' },
            { icon: '⇄', col: 'purple', name: 'Flip', desc: 'Change All Cards To Its Color.' },
            { icon: '⊘', col: 'purple', name: 'Barrier', desc: 'Block Entropy (2 Rounds).' },
            { icon: '⧉', col: 'purple', name: 'Clone', desc: 'Duplicate Card Of Its Color.' },
            { icon: '1#', col: 'purple', name: 'Add 1', desc: 'Value +1 For Its Color.' },
            { icon: '2#', col: 'purple', name: 'Add 2', desc: 'Value +2 For Its Color.' }
            ];

            list.innerHTML = allCards.map(c => `
            <div class="bg-white/5 border border-white/5 p-3 rounded-2xl flex flex-col items-center text-center hover:bg-white/10 transition-colors">
                <div class="w-10 h-14 rounded-lg c-${c.col} flex items-center justify-center font-black shadow-lg text-white text-lg mb-2">${c.icon}</div>
                <h4 class="text-white text-[9px] font-black uppercase leading-tight">${c.name}</h4>
                <p class="text-zinc-500 text-[8px] leading-tight mt-1 px-1">${c.desc}</p>
            </div>
            `).join('');
        }
        const COLORS = ['red', 'blue', 'green', 'yellow'];
        const VALUES = ['1', '2', '3', '4', '5', '6', '7', '8', '9'];
        const NEUTRAL_SPECIALS = [
            { type: 'BOOST', icon: '+2', color: 'zinc', isSpecial: true },
            { type: 'MERGE', icon: '⧈', color: 'zinc', isSpecial: true },
            { type: 'DICE', icon: '⚁', color: 'zinc', isSpecial: true },
            { type: 'SHIFT', icon: '⎎', color: 'zinc', isSpecial: true }
        ];
        const COLOR_SPECIALS = [
            { type: 'FLIP', icon: '⇄', isSpecial: true },
            { type: 'BARRIER', icon: '⊘', isSpecial: true },
            { type: 'CLONE', icon: '⧉', isSpecial: true },
            { type: 'ADD1', icon: '1#', isSpecial: true },
            { type: 'ADD2', icon: '2#', isSpecial: true }
        ];

        let state = {
            isOpeningPhase: true, protectedCards: 0,
            highScore: localStorage.getItem('cardflux_highscore') || 0,
            score: 0, volatility: 0, multiplier: 1.0, hand: [], active: null, next: null,
            selected: [], meltdownTime: null, isGameOver: false, aiSuggestionIdx: -1,
            burnTurns: 0, barrierTurns: 0, cycle: 'night', skin: 'default',
            mergeMode: false, mergeSelected: []
        };

        function showToast(msg) {
            const t = document.getElementById('toast');
            t.innerText = msg;
            t.style.opacity = '1';
            t.style.transform = 'translateX(-50%) translateY(-10px)';
            setTimeout(() => {
                t.style.opacity = '0';
                t.style.transform = 'translateX(-50%) translateY(0)';
            }, 1500);
        }
        function startDicePhase() {
            state.isOpeningPhase = true;
            let roll1 = Math.floor(Math.random() * 6) + 1;
            let roll2 = Math.floor(Math.random() * 6) + 1;
            state.protectedCards = roll1 + roll2;
            for(let i = 0; i < state.protectedCards; i++) {
                state.hand.push(generateTrulyRandom());
            }
    
            showToast(`ROLLED ${roll1} & ${roll2}: ${state.protectedCards} CARDS`);
            render();
        }
        function init() {
            state.highScore = localStorage.getItem('cardflux_highscore') || 0;
            state = { ...state, score: 0, volatility: 0, multiplier: 1.0, hand: [], selected: [], meltdownTime: null, isGameOver: false, burnTurns: 0, barrierTurns: 0, mergeMode: false, mergeSelected: [] };
            state.active = generateTrulyRandom();
            state.next = generateSmartCard();
            state.isOpeningPhase = true;
            let roll1 = Math.floor(Math.random() * 6) + 1;
            let roll2 = Math.floor(Math.random() * 6) + 1;
    
            state.protectedCards = roll1 + roll2;
            for(let i = 0; i < state.protectedCards; i++) {
            state.hand.push(generateTrulyRandom());
            }
            showToast(`ROLLED ${roll1} & ${roll2}: ${state.protectedCards} CARDS`);
            document.getElementById('game-over').classList.add('opacity-0', 'pointer-events-none');
            render();
            requestAnimationFrame(gameLoop);
        }

        function generateTrulyRandom() {
            const rand = Math.random();
            if (rand > 0.92) {
                return { ...NEUTRAL_SPECIALS[Math.floor(Math.random() * NEUTRAL_SPECIALS.length)] };
            } else if (rand > 0.82) {
                const spec = { ...COLOR_SPECIALS[Math.floor(Math.random() * COLOR_SPECIALS.length)] };
                spec.color = COLORS[Math.floor(Math.random() * COLORS.length)];
                return spec;
            }
            return { color: COLORS[Math.floor(Math.random()*COLORS.length)], val: VALUES[Math.floor(Math.random()*VALUES.length)], isSpecial: false };
        }

        let isSmart = Math.random() < 0.70;

        function generateSmartCard() {
            if (!isSmart || !state.active) return generateTrulyRandom();
            const rand = Math.random();
            if (rand < 0.26) return { ...NEUTRAL_SPECIALS[Math.floor(Math.random() * NEUTRAL_SPECIALS.length)] };
            if (rand < 0.36)
            if (rand < 0.36) {
                const spec = { ...COLOR_SPECIALS[Math.floor(Math.random() * COLOR_SPECIALS.length)] };
                spec.color = (state.active.color === 'zinc') ? COLORS[Math.floor(Math.random()*4)] : state.active.color;
                return spec;
            }
            const helpType = Math.random() > 0.64 ? 'color' : 'value';
            return helpType === 'color' ? 
                { color: (state.active.color === 'zinc') ? COLORS[Math.floor(Math.random()*4)] : state.active.color, val: VALUES[Math.floor(Math.random()*VALUES.length)], isSpecial: false } :
                { color: COLORS[Math.floor(Math.random()*COLORS.length)], val: state.active.val || VALUES[Math.floor(Math.random()*VALUES.length)], isSpecial: false };
        }

        function toggleSelect(idx) {
            if (state.isGameOver) return;
            if (state.mergeMode) {
                const alreadyIdx = state.mergeSelected.indexOf(idx);
                if (alreadyIdx !== -1) {
                    state.mergeSelected.splice(alreadyIdx, 1);
                } else if (state.mergeSelected.length < 2) {
                    const card = state.hand[idx];
                    if (card.isSpecial) return; 
                    if (state.mergeSelected.length === 1) {
                        const first = state.hand[state.mergeSelected[0]];
                        if (first.color === card.color) {
                            state.mergeSelected.push(idx);
                            executeMerge();
                        }
                    } else {
                        state.mergeSelected.push(idx);
                    }
                }
                render();
                return;
            }
            const selIdx = state.selected.indexOf(idx);
            if (selIdx !== -1) {
                if (selIdx === state.selected.length - 1) state.selected.pop();
            } else {
                const prev = state.selected.length > 0 ? state.hand[state.selected[state.selected.length-1]] : state.active;
                const curr = state.hand[idx];
                if (curr.color === 'zinc' || prev.color === 'zinc' || curr.color === prev.color || curr.val === prev.val) state.selected.push(idx);
            }
            render();
        }

        function cancelSpecialModes() {
            state.mergeMode = false;
            state.mergeSelected = [];
            state.selected = []; 
            showToast("MERGE CANCELED");
            render();
        }

        function executeMerge() {
            const [idx1, idx2] = state.mergeSelected;
            const card1 = state.hand[idx1];
            const card2 = state.hand[idx2];
            const newVal = Math.min(9, parseInt(card1.val) + parseInt(card2.val));
            card1.val = newVal.toString();
            state.hand.splice(idx2, 1);
            state.mergeMode = false;
            state.mergeSelected = [];
            showToast("MERGED #s");
            render();
        }

        function executeAction() {
            if (state.selected.length === 0) return;
            const playedCards = state.selected.map(idx => state.hand[idx]);
            const lastPlayed = playedCards[playedCards.length - 1];
            const mergeCardIdx = state.selected.findIndex(idx => state.hand[idx].type === 'MERGE');
            const mergeCard = playedCards.find(c => c.type === 'MERGE');
            
            if (mergeCard) {
                state.mergeMode = true;
                state.hand.splice(state.selected[mergeCardIdx], 1);
                state.selected = [];
                showToast("SELECT 2 CARDS TO MERGE #");
                render();
                return;
            }
            const boostCardIdx = state.selected.findIndex(idx => state.hand[idx].type === 'BOOST');
            if (boostCardIdx !== -1) {
                for(let i=0; i<2; i++) if(state.hand.length < 15) state.hand.push(generateTrulyRandom()); 
                state.hand.splice(state.selected[boostCardIdx], 1);
                state.selected = [];
                showToast("+2 CARDS"); 
                render();
                return;
            }
            const shiftCardIdx = state.selected.findIndex(idx => state.hand[idx].type === 'SHIFT');
            if (shiftCardIdx !== -1) {
                state.active = generateTrulyRandom();
                state.hand.splice(state.selected[shiftCardIdx], 1);
                state.selected = [];
    
                showToast("TARGET SHIFTED");
                render();
                return;
            }
            let pts = 0;
            const chainCount = state.selected.length;
            let remainingHand = state.hand.filter((_, i) => !state.selected.includes(i));

            playedCards.forEach(card => {
                if (card.isSpecial) {

                    if (card.type === 'DICE') {
                        const roll = Math.floor(Math.random() * 6) + 1;
    
                        if (roll <= 4) {
        
                            for(let i = 0; i < roll; i++) {
                                if(state.hand.length < 15) state.hand.push(generateTrulyRandom());
                            }
                            state.volatility += (roll * 6);
                            showToast(`ROLLED ${roll}: +${roll} CARDS / +${roll * 6}% ENTROPY`);
                        } else if (roll === 5) {
                            state.volatility = Math.max(0, state.volatility - 30);
                            showToast("JACKPOT: -30% ENTROPY");
                        } else if (roll === 6) {
                            state.volatility += 30;
                            showToast("CRITICAL FAIL: +30% ENTROPY");
                        }
                    }
                    if (card.type === 'FLIP') { 
                        state.hand.forEach(c => { if(!c.isSpecial) c.color = card.color }); 
                        showToast(`${card.color.toUpperCase()} ALIGNMENT`); 
                    }
                    if (card.type === 'BARRIER') {
                        state.barrierTurns = 2;
                        showToast("% BLOCKED");
                    }
                    if (card.type === 'CLONE') { 
                        const sameColorUnits = remainingHand.filter(h => h.color === card.color && !h.isSpecial);
                        if (sameColorUnits.length > 0) {
                            const target = sameColorUnits[Math.floor(Math.random() * sameColorUnits.length)];
                            state.hand.push(JSON.parse(JSON.stringify(target))); 
                            showToast(`${card.color.toUpperCase()} CLONED`); 
                        } else {
                            showToast("NO VALID TARGET");
                        }
                    }
                    if (card.type === 'ADD1' || card.type === 'ADD2') {
                        const amt = card.type === 'ADD1' ? 1 : 2;
                        state.hand.forEach(c => { 
                            if (!c.isSpecial && c.color === card.color) { 
                                let v = Math.min(9, parseInt(c.val) + amt); 
                                c.val = v.toString(); 
                            } 
                        });
                        showToast(`${card.color.toUpperCase()} CARD VALUE +${amt}`);
                    }
                } else {
                    pts += parseInt(card.val) * 20;
                }
            });

            const reduction = chainCount * 10;
            state.volatility = Math.max(0, state.volatility - reduction);
            state.score += Math.floor(pts * state.multiplier * (1 + (chainCount * 0.4)));
            state.multiplier = Math.min(25, state.multiplier + (chainCount * 0.15));
            state.active = JSON.parse(JSON.stringify(lastPlayed));
            state.hand = state.hand.filter((_, i) => !state.selected.includes(i));
            state.selected = [];
            render();
        }

        function drawCard() {
            if (state.isGameOver || state.hand.length >= 15 || state.mergeMode) return;
            state.hand.push(state.next);
            state.next = generateSmartCard();
            if (state.protectedCards > 0) {
                state.protectedCards--; 
            if (state.protectedCards === 0) {
                state.isOpeningPhase = false;
            }
            } else {
                if (state.barrierTurns > 0) {
            state.barrierTurns--;
            showToast("% BLOCKED");
            } else {
            state.volatility += 7;
        }
    }
            if (state.burnTurns > 0) state.burnTurns--;
            render();
        }

        function gameLoop() {
            if (state.isGameOver) return;
            if (state.hand.length > 9 && state.barrierTurns === 0) {
                state.volatility += 0.025;
            }
            if (state.score > state.highScore) {
                state.highScore = state.score;
                localStorage.setItem('cardflux_highscore', state.highScore);
            }
            if (state.score < 19999) isSmart = 0.87;
            if (state.score >= 20000 && state.score < 40000) isSmart = 0.65;
            if (state.score >= 40001 && state.score < 100000) isSmart = 0.39;
            if (state.score >= 100001 && state.score < 500000) isSmart = 0.15;
            if (state.score >= 500001 && state.score < 1000000) isSmart = 0.05;
            if (state.score >= 1000001) isSmart = 0.02;

            const fillEl = document.getElementById('vol-fill');
            if (state.barrierTurns > 0) fillEl.classList.add('barrier-active');
            else fillEl.classList.remove('barrier-active');

            if (state.volatility >= 100) {
                if (!state.meltdownTime) state.meltdownTime = Date.now() + 5000;
                const rem = (state.meltdownTime - Date.now()) / 1000;
                document.getElementById('meltdown-timer').classList.remove('hidden');
                document.getElementById('timer-val').innerText = rem.toFixed(1);
                fillEl.classList.add('meltdown');
                if (rem <= 0) { state.isGameOver = true; showGameOver(); }
            } else {
                state.meltdownTime = null;
                document.getElementById('meltdown-timer').classList.add('hidden');
                fillEl.classList.remove('meltdown');
            }
            fillEl.style.width = `${state.volatility}%`;
            fillEl.style.backgroundColor = state.volatility > 80 ? '#ff3b30' : (state.volatility > 50 ? '#ffcc00' : (state.barrierTurns > 0 ? '#007aff' : '#34c759'));
            document.getElementById('vol-pct').innerText = `${Math.floor(state.volatility)}%`;
            requestAnimationFrame(gameLoop);
        }

        function showGameOver() {
            document.getElementById('final-score').innerText = state.score.toLocaleString();
            document.getElementById('game-over').classList.remove('opacity-0', 'pointer-events-none');
            const finalScore = state.score;
            const isNewRecord = finalScore > state.highScore;

            if (isNewRecord) {
                state.highScore = finalScore;
                localStorage.setItem('cardflux_highscore', finalScore);
            }
            let hsDisplay = document.getElementById('high-score-display');
            if (!hsDisplay) {
                hsDisplay = document.createElement('p');
                hsDisplay.id = 'high-score-display';
                hsDisplay.className = "text-[10px] uppercase font-bold text-purple-500 mt-4";
                document.getElementById('final-score').parentNode.appendChild(hsDisplay);
            }
    
            hsDisplay.innerText = isNewRecord ? 
            `NEW BEST!` : 
            `BEST: ${parseInt(state.highScore).toLocaleString()}`;
        }

        function resetGame() { init(); }

        function render() {
            document.getElementById('score').innerText = state.score.toLocaleString();
            document.getElementById('hand-cap').innerText = `${state.hand.length}/15 Units`;
            const mergeUI = document.getElementById('merge-ui');
            const mergeInstr = document.getElementById('merge-instructions');
            if (state.mergeMode) {
                mergeUI.classList.add('active');
                const triggerCard = state.hand.find(c => c.type === 'MERGE') || {color: '?'};
                if (state.mergeSelected.length === 0) mergeInstr.innerText = `Select first ${triggerCard.color.toUpperCase()} card`;
                else if (state.mergeSelected.length === 1) mergeInstr.innerText = `Select second ${triggerCard.color.toUpperCase()} card`;
            } else {
                mergeUI.classList.remove('active');
            }
            const aiStatus = document.getElementById('ai-status');
            if (aiStatus) {
                const smartPct = Math.round(isSmart * 100);
                aiStatus.innerText = `AUTO HELP: ${smartPct}%`;
        
                if (isSmart > 0.4) {
                    aiStatus.className = "text-[9px] font-black uppercase tracking-widest px-2 py-0.5 rounded bg-green-500/10 text-green-500";
                } else if (isSmart > 0.1) {
                    aiStatus.className = "text-[9px] font-black uppercase tracking-widest px-2 py-0.5 rounded bg-yellow-500/10 text-yellow-500";
                } else {
                    aiStatus.className = "text-[9px] font-black uppercase tracking-widest px-2 py-0.5 rounded bg-red-500/10 text-red-500";
                }
            }
            const burnInd = document.getElementById('burn-indicator');
            if (state.burnTurns > 0) {
                burnInd.classList.remove('hidden');
                document.getElementById('burn-count').innerText = state.burnTurns;
            } else burnInd.classList.add('hidden');

            const barrierInd = document.getElementById('barrier-indicator');
            if (state.barrierTurns > 0) {
                barrierInd.classList.remove('hidden');
                document.getElementById('barrier-count').innerText = state.barrierTurns;
            } else barrierInd.classList.add('hidden');

            const nextPrv = document.getElementById('next-card');
            nextPrv.className = `next-preview c-${state.next.color} mt-1 shadow-inner`;
            nextPrv.innerHTML = `<span class="opacity-80">${state.next.isSpecial ? state.next.icon : state.next.val}</span>`;
            
            const target = document.getElementById('target-card');
            target.className = `w-32 h-44 sm:w-36 sm:h-52 rounded-[28px] flex items-center justify-center shadow-2xl c-${state.active.color} ${state.burnTurns > 0 ? 'ring-4 ring-red-500/50' : ''} ${state.barrierTurns > 0 ? 'ring-4 ring-blue-500/50' : ''}`;
            target.innerHTML = `<span class="text-6xl font-black">${state.active.isSpecial ? state.active.icon : state.active.val}</span>`;
            document.getElementById('best-hud').innerText = parseInt(state.highScore).toLocaleString();
            const handEl = document.getElementById('hand');
            handEl.innerHTML = '';
            state.hand.forEach((c, i) => {
                const sel = state.selected.includes(i);
                const mergeSel = state.mergeSelected.includes(i);
                let extraClass = '';
                if (sel) extraClass = 'selected';
                if (mergeSel) extraClass = 'merge-selected';
                if (state.mergeMode) {
                    const firstIdx = state.mergeSelected[0];
                    if (firstIdx !== undefined) {
                        const firstCard = state.hand[firstIdx];
                        if (c.color !== firstCard.color || c.isSpecial) extraClass += ' opacity-20 grayscale';
                    } else if (c.isSpecial) extraClass += ' opacity-20 grayscale';
                }
                const p = document.createElement('div');
                p.className = `card-pill c-${c.color} ${extraClass}`;
                p.innerHTML = `<span class="text-3xl font-black">${c.isSpecial ? c.icon : c.val}</span>`;
                p.onclick = () => toggleSelect(i);
                handEl.appendChild(p);
            });

            const btn = document.getElementById('action-btn');
            if (state.selected.length > 0 && !state.mergeMode) {
                btn.classList.remove('hidden');
                const isMerge = state.hand[state.selected[0]].type === 'MERGE';
                btn.innerText = isMerge ? "Merge" : (state.selected.length > 1 ? "Play Chain" : "Play Card");
            } else btn.classList.add('hidden');
        }

        init();
    </script>
</body>
</html>
